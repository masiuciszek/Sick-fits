---
title: Recursion
spoiler: Recursion is a powerful technique that helps us bridge the gap between complex problems being solved with elegant code.
date: "2021-04-26"
updated: "2020-08-02"
tags: ["CS", "recursion"]
keywords: ["recursion", "CS"]
slug: recursion
---

Recursion is a powerful technique to know as a software engineer.
Recursion is a function that calls itself until it hits our because otherwise, it will keep stuck in an infinite loop.
It may return a value ore it doesn't.
That's why we need our condition on some parameter such that when we hit some condition at some point we will stop the recursion.

```ts
const countToTen = (n: number): number => {
  if (n === 10) return n // Basecase, otherwise we will never stop running the function.
  console.log(n) // 0 1 2 3 4 5 6 7 8 9 10
  return countToTen(n + 1) // receive call
}

console.log(countToTen(0))
```

Have you seen the movie Inception where they go into other people's dreams, they could go an infinite amount of levels deep, and to know they are still in a dream they have the token that tells them if they are kept in the dream or not.
The token is the base case, it will help us to not keep going deeper until we lose control and never can wake up from the dream.

## Recursions are lazy

If we think we would be a recursive function, just for a moment.
We just want to do as little work as possible to achieve the result, as soon we hit our base case we are done.

## Why ore why not use recursion?

| pros                                                                      | cons                                                    |
| ------------------------------------------------------------------------- | ------------------------------------------------------- |
| Elegance and complexity                                                   | make the CPU work alot,slowness                         |
| Reduce complex imperative loops, such as traverse a tree                  | can lead out of memory fast, `stackoverflow`            |
| Reduce time complexity, with memoization                                  | Can be more complex then needed if written in a bad way |
| Works really well with data structures, like for example `graphs`,`trees` |                                                         |

## Callstack

To understand how the recursion works and how the process of the whole execution we need to understand the `call stack`.
The call stack is a `stack` based data structure. To explain more how the call stack works let's visualize our day.

Let's say you go to work one day, you want to start your day by reading a blog post that you wanted to read and that you prepared for this morning.
While you reading you hearing your boss knocking on your shoulder and says: _I need you to attend the meeting in 5min_.
So you now need to attend the meeting, and the reading is the second prioritized since the meeting is important, well you can read the post after the meeting.
Then your boss walks in again and says that you need not attend this other meeting that you should impress some investors, and that's is what you will do, impress the investors is now more important.
Then the boss says once again I need you to help `John` with his code, It is urgent and we need to ship this code into production as soon as possible.

So now you can't:

- Read your blog post
- attend to the first meeting
- impress the investors

Until you help John with his code.
But once you help `John` it gets popped out from your to-do list and you can then impress the investors.
After that, you can attend the meeting.
When you are done with the meeting you will have some time to read your blog post.
This is a visualized way of how the call stack works.

So why is this so relevant to how recursion works.
This is how the call stack works when we are talking about invoking functions within our program.

Take this, for example, we have three functions that are kind of chained together.

```js
function a() {
  return "What up " + b()
}

function b() {
  return "I am B " + "Hello " + c()
}

function c() {
  return "I am C"
}
```

The first function is dependent on the `c` function and returns a string.
`b` is dependent on `c` and it also returns a string.
And `c` just return a string nothing special here.

And here is the order of the call stack, in what order the functions will be invoked.
Here we can also see how the function gets popped out from the call stack and how for example we invoke the `b` and `c`
functions after the previous task have been completed and popped off the call stack.

<Image src="/static/images/call-stack-ex.svg" height={500} width={800} />

So why is this even relevant to how recursion works and how we think recursively?
So let's show a recursive example when achieving StackOverflow and when our machine would crash because it cant handle more items on the stack, so we achieve `StackOverflow.
Running this function will just add the function to the call stack and never get any chance to pop it from the call stack when the functions get invoked.
We have simply run out of memory that our machine can handle. The pre-allocated buffer of memory has exceeded.

```js
function recFunc() {
  recFunc() // call itsel with no basecase ---> stackoverflow
}
```

This is the whole point of why we need the base case so we don't run out of memory and reach a state of `StackOverflow`.

<Image src="/static/images/call-stack.svg" height={500} width={800} />

### Recursion using strings

Let's reverse a string using recursion.
Two important questions to ask yourself before implementing your recursive function should be:

- What is the base case?
- What is the smallest amount of work I need to do to achieve the final result?

```ts
const reverseStringRec = (input: string): string => {
  // what is the base case?
  // What is smallest amount of work I need to do to achieve the final result?
}
```

A good way of thinking of the base case is when is the smallest amount of the import we can reach that we need immodestly stop our function to run.
Remember we want to make the function as lazy as possible, so a good base case would be to check when we have an empty string then the function should imminently return.

The next thing to deal with is to implement the logic. What is the smallest work we can do to achieve our goal?
So once again what is the smallest unit we can work with?
Strings are built with a bunch of characters and we could just simply work with the characters one by one to modify the string.

```ts
const reverseStringRec = (input: string): string => {
  if (string === "") return string
  // What is smallest amount of work I need to do to achieve the final result?
}
```

So our implementation could look like this.
We simply take the first character from the input string, and we concatenate it after our recursive call.
We want to reach our because that is our goal. So building our mental model around that helps a lot.
This is nice because we don't need to keep track of each letter on where it should be put. We make the function deal with that.
Every function call will be added to the call stack and will not be popped from the call stack until we hit our base case.
So basically when we hit the base case every function will be popped out from the call stack.

```ts
const reverseStringRec = (string: string): string => {
  if (string === "") return string
  return reverseStringRec(string.slice(1)) + string.charAt(0)
}

reverseStringRec("hello") // olleh
```

I think this is a very elegant way to reverse a string using recursion, we simply add out functions to the call stack and let the call stack deal with that,
we don't care about any more implementation details just getting back our expected result back.

**Another good example** is to check if a string is a palindrome using recursion.

<Image src="/static/images/palindrome.svg" height={500} width={800} />

A palindrome is if a string is the same word as its reversed version. So for example `racecar`
reversed is still `racecar`.

We want to have two pointers, one that starts from the beginning of the string and one that starts from the end.
We will check if the first letter is equal to the last letter then we will go one step forward with one pointer and backwords with the second pointer.

without using recursion it could look something like this where `i` is our start pointer and `j` is our end pointer.

```ts
const isPlaindrome = (s: string): boolean => {
  let i = 0
  let j = s.length - 1
  while (i < j) {
    if (s[i] !== s[j]) {
      return false
    }
    i++
    j--
  }

  return true
}
```

And here is the implementation using recursion.
If the input string is empty or has one character there is no proof that it is not a palindrome so we return true.
Instead of define two pointers in our previous implementation where we needed to increment and decrement the pointers.
we instead check for every function call if the first letter is equal to the last letter.
if that's the case we continue until we hit our base case and return true else we will return false.

```ts
const palindrome = (s: string): boolean => {
  if (s.length === 0 || s.length === 1) return true // basecase
  if (s.charAt(0) === s.charAt(s.length - 1)) {
    // our logic
    return palindrome(s.slice(1, s.length - 1))
  }
  return false
}
```

### Recursion using numbers

Let's have a look at how we work with numbers using recursion. Let's implement a function that takes in a number and sum up all the values up to that number
using recursion.
This function should return `55`.

```ts
const recursiveSummation = (n: number): number => {
  if (n <= 0) {
    return n
  }
  return n + recursiveSummation(n - 1)
}
recursiveSummation(10) // 55
```

We add the current value of `n` and add to the recursive call where we subtract the previous value.
We will keep adding to the call stack until we hit our base case.
So for every function call, the value of `n` will be shrunk and another stack frame will be added to the call stack.

- 10 recursiveSummation(n - 1)
- 9 recursiveSummation(n - 1)
- 8 recursiveSummation(n - 1)
- 7 recursiveSummation(n - 1)
- 6 recursiveSummation(n - 1)
- 5 recursiveSummation(n - 1)
- 4 recursiveSummation(n - 1)
- 3 recursiveSummation(n - 1)
- 2 recursiveSummation(n - 1)
- 1 recursiveSummation(n - 1)

Another common example to demonstrate recursion with numbers is to implement the Fibonacci sequence.
If you don't know what thee Fibonacci works. Each number is the sum of two preceding ones, starting from 0 and 1.
`0, 1, 1, 2, 3, 5, 8, 13, 21, 34`

This is a very elegant solution to solve this problem using recursion. This function is not optimized since we do a lot of the same calculation more than once.
To optimize this we could use memoization.
But just build another mental model, it is a great example to see how the Fibonacci sequence is implemented.

```ts
const fib = (n: number): number => {
  if (n === 0 || n === 1) {
    return n
  }
  return fib(n - 2) + fib(n - 1)
}
```

And here is the memoized version of the Fibonacci sequence.
In this case, we will not recalculate what we already know. The call stack will not have multiple function calls that need to be handled that will give us
the same result.
We store what we already calculated in the cache`(map)` if we have it just use it else we add it to the cache.
Try to run the first version with fib`(50)` and the second version and check out how much faster the memoized version is.

```ts
const fibMemo = () => {
  const cache: Record<string, number> = {}
  const fib = (n: number): number => {
    if (cache[n]) {
      return cache[n]
    }
    if (n < 3) {
      cache[n] = n - 1
      return n - 1
    }
    const result = fib(n - 2) + fib(n - 1)
    cache[n] = result
    return result
  }
  return fib
}
```

### Reverse a Linked list

Sometimes if your interviewer wants to be hard on you he/she might ask you to reverse a linked list. A good mental model to reverse a linked list is the core to solve this problem.
But with using recursion it gets much more simplified and elegant if you ask me.
Basically we want our tail to be our head and our head to be the tail + all its siblings to follow the same pattern.

```shell
1 --> 7 --> 34 --> 2 --> 23

# Aftere we have reversed the list
23 --> 2--> 34 --> 7 --> 1
```

```ts
const reverseList = (node: Node) => {
  if (node === null || node.next === null) return node
  const p = this.reverse(node.next)
  node.next.next = node
  node.next = null
  return p
}
```

### Using recursion in your front end application.

We can also use recursion in our projects and sometimes it is a much more handy, elegent and better tool to use then iterate over a list.
For example if we want to render a tree data structure in our React application..
We don't know how many level deep the tree has and we still want to make it dynamic so if the tree grows we don't want to update the code all the time, this can simply be solved using recursion.
The tru fact is that our machines using recursion under the hood wehn we try to run a script that searches for folders and files on our machine.

For example a folder structure where we have the main root folder and it can have children as folders and inside the folders we have our files.

We can build this with React, here is the full code example [repository](https://github.com/) if you want to checkout it out.

we want to stope the recursion as soon we hit our base case, if their is no more items left.

```tsx
const Tree: FC<TreeProps> = ({treeData, parentId = 0, level = 0}) => {
  const items = treeData.filter((item) => item.parentId === parentId)
  if (!items || !items.length) return null // Base case

  return items.map((item) => (
    <div key={item.id}>
      <Wrapper level={level} item={item}>
        <Tree treeData={treeData} parentId={item.id} level={level + 1} />
      </Wrapper>
    </div>
  ))
}

getTreeData = () => {
  return data.map((x) => ({
    ...x,
    hasChildren: data.filter((item) => item.parentId === x.id).length > 0,
  }))
}

const App = () => (
  <div>
    <Container>
      <Tree treeData={getTreeData()} />
    </Container>
  </div>
)
```

This tecnique was something I got inspred and learned from [dev1] and [dev2] since I had a situation at my job where I need to build something similar to this.
