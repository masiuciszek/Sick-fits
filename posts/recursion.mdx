---
title: Recursion
spoiler: Recursion is a powerful technique that helps us bridge the gap between complex problems being solved with elegant code.
date: "2021-04-26"
updated: "2020-08-02"
tags: ["CS", "recursion"]
keywords: ["recursion", "CS"]
slug: recursion
---

Recursion is a poweful technique to know as a software engineer.
Basiccly a recusrion is a function that calls it self until it hits our basecase, otherwise it will keep in stuck in a infinite loop.
It maybe returrns a value ore i doesent.
Thats why we need our condition on some parameter such theat when we hit some condition at some point we will stop the recursion.

```ts
const countToTen = (n: number): number => {
  if (n === 10) return n // Basecase, otherwise we will never stop running the function.
  console.log(n) // 0 1 2 3 4 5 6 7 8 9 10
  return countToTen(n + 1) // receive call
}

console.log(countToTen(0))
```

Have you seen the movie Inception where they go into other peoples dreams, they could go infinite amount of levels deep, and to know they are still in a dream they have their token that tells them if they are kept in the dream or not.
The token is the base case, it will help us to not keep going deeper until we loose the control and never can wake up from the dream.

## Recursions are lazy

## Why ore why not use recursion?

| pros                                                                      | cons                                                    |
| ------------------------------------------------------------------------- | ------------------------------------------------------- |
| Elegance and complexity                                                   | make the CPU work alot,slowness                         |
| Reduce complex imperative loops, such as traverse a tree                  | can lead out of memory fast, `stackoverflow`            |
| Reduce time complexity, with memoization                                  | Can be more complex then needed if written in a bad way |
| Works really well with data structures, like for example `graphs`,`trees` |                                                         |

## Callstack

To understand how the recursion works and how the process of the whole execution we need to understand the `call stack`.
The call stack is a `stack` based data structure. To explain more how the call stack works lets visualize our day.

Let's say you go to work one day, you want to start your day by reading a blog post that you wanted to read and that you prepared for this morning.
While you reading you hearing your boss knocking on your shoulder and says: _I need you to attend the meeting in 5min_.
So you now need to attend the meeting, and the reading is the second prioritized since the meeting is important, well you can read the post after the meeting.
Then your boss walks in again and says that you need not attend this other meeting that you should impress some investors, and that's is what you will do, impress the investors is now more important.
Then the boss says once again I need you to help `John` with his code, It is urgent and we need to ship this code into production as soon as possible.

So now you can't:

- Read your blog post
- attend to the first meeting
- impress the investors

Until you help John with his code.
But once you help `John` it gets popped out from your to-do list and you can then impress the investors.
After that, you can attend the meeting.
When you are done with the meeting you will have some time to read your blog post.
This is a visualized way of how the call stack works.

So why is this so relevent to how recursion works.
This is how the call stack works when we are talking about invoking function within our program.

Take this for example, we have three functions that are kind of chained together.

```js
function a() {
  return "What up " + b()
}

function b() {
  return "I am B " + "Hello " + c()
}

function c() {
  return "I am C"
}
```

The first function is depended on the `c` function and returns a string.
`b` is depended on `c` and it also returns a string.
And `c` just return a string nothing speciall here.

And here is the order of thee call stack, in what order the functions will be invoked.
Here we can also se how the function get poped out from the call stack and how for exemple we invoke the the `b` and `c`
functions after the previous task has been completed and popped of the call stack.

<Image src="/static/images/call-stack-ex.svg" height={500} width={800} />

So why is this even relevent to how recursion works and how we think recursevly?
So let's show a recursive example when achive stackoverflow and when our machine would crach beacuse it cant handle more items on thee stack, so we achive `stackoverflow`.
Running this function it will just add the function to the callstack and never get any chance to pop it from the call stack when the functions get invoked.
We have simply run out of memory that our machine can handle. The pre allocated buffer of memory has exceded.

```js
function recFunc() {
  recFunc() // call itsel with no basecase ---> stackoverflow
}
```

This is the whole point why we need the basecase so we dont run out of memory and reache an state of `stackoverflow`.

<Image src="/static/images/call-stack.svg" height={500} width={800} />

### Recursion using strings

Let's reverse a string using recursion.
Two importatn questions to ask yourself before implementing your recursive function should be:

- What is the base case?
- What is smallest amount of work I need to do to achieve the final result?

```ts
const reverseStringRec = (input: string): string => {
  // what is the base case?
  // What is smallest amount of work I need to do to achieve the final result?
}
```

A good way of thinking of the base case is when is the smallest amount of the impunt we can reach that we need imidetly stop our function to run.
Rememeber we want to make the function as lazy as possible, so a good base case would be to check when we have an empty string then the funcction should imidetly return.

Next thing to deal with is to implementing the logic. What is the smallest work we can do to achive our goal?
So sonce again what is the smallest unit we can work with?
Strings are built with a bunch of characters and we could just simply work with the characters one by one to modify the string.

```ts
const reverseStringRec = (input: string): string => {
  if (string === "") return string
  // What is smallest amount of work I need to do to achieve the final result?
}
```

So our implementation could look like this.
We simply take the first charachter from the input string, and we concatenate it after our recusrive call.
We want to reach our basecase that is our goal. So building our mental model around that really help a lot.
This is nice becasue we dont need to keep track of each letter on where it shoudl be put. We make the function deal with that.
Every function call will be added to the call stack and will not be popped from the call stack until we hit our base case.
So basically when we hit the base case every function will be popped out from the call stack.

```ts
const reverseStringRec = (string: string): string => {
  if (string === "") return string
  return reverseStringRec(string.slice(1)) + string.charAt(0)
}

reverseStringRec("hello") // olleh
```

I think this is a very elegent way to reverse a string using recursion, we simply add out functions tot he call stack and let the call stack deal with that,
we don't care about anymore implmentation details just getting back our expected result back.

**Another good example** is to chack if a string is a plaindrome using recustion.

<Image src="/static/images/palindrome.svg" height={500} width={800} />

A palindrome is if a string is the same word to its reversed version. So for example `racecar`
reversed is still `racecar`.

We basicly want to have two pointers, one that start from the beginning of the string and one that starts from the end.
Wi will basiccly check if the first letter is equalt to last letter then we will go one step forward wit one pointer and backwords with the second pointer.

without using recursion it could look something like this where `i` is our start pointer and `j` is our end pointer.

```ts
const isPlaindrome = (s: string): boolean => {
  let i = 0
  let j = s.length - 1
  while (i < j) {
    if (s[i] !== s[j]) {
      return false
    }
    i++
    j--
  }

  return true
}
```

And here is the implementation using recursion.
If the input string is empty ore has one charachter there is no profe that it is not a plaindrome so we return true.
Instead of define two pointers in our previous implementation where we needed to increment and decrement the pointers.
we instead check for every function call if the first letter is equal to the last letter.
if thats the case we continou until we hit the our base case and return true else we will return false.

```ts
const palindrome = (s: string): boolean => {
  if (s.length === 0 || s.length === 1) return true // basecase
  if (s.charAt(0) === s.charAt(s.length - 1)) {
    // our logic
    return palindrome(s.slice(1, s.length - 1))
  }
  return false
}
```
