---
title: Closures
spoiler: What is closures, and how do they actually work?
date: "2020-03-16"
updated: "2020-03-16"
tags: ["js", "fp"]
keywords: ["wtf", "vip"]
slug: js-closures
---

What are closures actually and why is this a so common term in programming.
If you have been applied for a JavaScript interview you probably got the question from the interviewer that you should explain what a closure is and how it works.

A closure is a function that can access stuff not inside of it.
Every function we create in `JavaScript` has a closure.
As soon we enable/call our function thir closures enable them to access the values from thier scopes.
So for example

> Closure is something that access the value the that is not defined inside of it.

Ore like [`Kyle Simpsons`](https://github.com/getify/You-Dont-Know-JS) defines clsures:

> Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.

```js
let name = "Filip"
const whatUp = () => {
  console.log(`hello ${name}`)
}
whatUp() // Filip

name = "Marcell"
whatUp() // Marcell
```

In this example, we will receive first hello Bob and then when we assign the name variable and call the function again we will get hello Marcell.
Another good example of how closures works is to implement a simple counter. Here we expect that the `i` varaible should be incremented by one for every function call.
And it does!

```js
let i = 0
const increment = () => {
  ++i
  console.log(i)
}
increment() //1
increment() //2
increment() //3
increment() //4
```

The increment function works as a closure and it is like it has its own memory and can remember what the previous I variable was.
So every time we would call the increment function we would receive an updated value of i-variable\.

**Something good to know is that:**
_A closure is created when you define a function not when we execute it. Then, every time we call that function, it will give us access to the defined `closures` from their function scopes\._

> It is the ability of a function to capture anything outside of the function and use that value every time our function gets called, that is what makes closures special.

So what would happened if we define the variable I inside the function?

```js
const increment = () => {
  let i = 0
  ++i
  console.log(i)
}
increment() //1
increment() //1
increment() //1
increment() //1
```

We would not get the same result as the previous example, that the I variable has been updated.
Every time we call the function we create a brand new function within the funcion scope.

But we don’t want to create global variables in our programs right?
What is so great with function in javascript is that all functions are first-class functions that mean that functions can be passed around as any value, we can define multiple functions inside another function.
The function can be passed as an argument to other functions, can be returned by another function, and can be assigned as a value to a variable.

Take the built-in higher-order functions like `Array.prototype.map`, `Array.prototype.filter`, and `Array.prototype.reduce`, for example, if you used them which is common when you write JavaScript programs, they can access the outer scoper thanks to closures.

But let’s go a little further and try to understand closures better by the understanding how the function life cycle works in `JavaScript.`

## Execution context

_Short about the life cycle of a JavaScript function\._

When we run our function, we create a brand new execution context, a brand new scope, when we are done that scope goes away.
If we call the same function a second time we create a whole different scope for that specifik exacution context, then the second scope goes away.

```js
function saySomething() {
  let name = "Marcell"
  console.log(`Hello there ${name}`)
}

saySomething()
saySomething()
```

The scopes are totaly different and have nothing common at all except that they use the same function.
The variable `name` inside the function will be recreated for every `execution context`.

Every function scope has its own lifetime, the get created and as soon they are doen they go away.
The only scope that never goes away is the `global` scope that is alive through the whole program.

## Scope and lexical scope

To create scope in JavaScript is when we define a function or a code block for example an if statement.
How we access a variable inside a block is managed by the scope.

So back to our counter-example:
When we define the variable inside the function we can’t access it outside the function scope,
We have simply created a private variable defined inside the function block.
We only have access to the variable inside the function scope.

Since the variables we create are just bounded to the scope where they got created, we can define a new variable with the same name and value inside another function because they are not defined within the same function scope.

We can do nested scopes and here is when the true power kicks in by using closures and understanding how the scope works.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

- You see here how the inner function `(child)` have access to the parent scope.
- We can nest scopes, and the inner function has access to the variables that are defined in the parent scope.
- Parent function does not have access to the child scope.

What whould happend in this case?
Do we expect the same result, do we get the same kind of error since we defining 2 variables within the same name?
Let's see what result we get.'

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    let parentVariable = "From the child"
    console.log(parentVariable)
  }
  child()
}

parent() // From the child
```

We print the value of the variable that gets defined inside the child function, since it was created from its function scope it will use that variable even if we have the same variable defined in the parent scope.
Since they are defined in different scopes we will not get any error, in this case, we just shadowing the `parentVariable` defined in the parent function scope.

But how can the child functions have access to the variable defined in the parent scope? As well as how does JavaScript knows what variable is corsponds to what scope?
This is when we come to understanding the `lexical` scope in JavaScript.
JavaScript does also have a concept called `lexical scope`, that inside a inner scope we still have acceess to the outer scope, so in the example the parent scope.

We can brake it down in to a metafor how the compiler compile ot JavaScript code.

Take the first example in this case.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

1. First we declare the `parent` function, and the compiler says: _hey I can see that you declared a varaible inside the parent function named `parentVariable`_
2. _Hey but I can also see that you using a variable without any declaration, I know `lexical scoping` so I will just use the variable that is defined in scope above `(the parent scoper)`_

### Don't mix closures and scopes

We should not mix these two concepts because they are not the same.
Closures spans multiple scopes and will not go away even after the function is done executing.
A difference between scopes and closures are that a closure will still live after the function execution shile scopes has their lifetime.

What will this code print?

```js
let x = 10

function a() {
  console.log(x)
}

function b() {
  let x = 222
  a()
}

b() // ????
```

It will print `10`, since the closure of the `a function` has only access to the global scope and to it's own scope, the scope of `function b` where we execute the `a function` does not affect the closure att all.

### Closures and shared scopes

Closures can even share scopes, So if we have main function and inside of it 3 other functions, they can modify the varible becasue they will capture the same value.
So for example:

```js
function Parent() {
  let x = 3

  const square = () => {
    x = x ** 2
    console.log(x)
  }
  const add = () => {
    x += 1
    console.log(x)
  }
  const half = () => {
    x /= 2
    console.log(x)
  }
  return {
    square,
    add,
    half,
  }
}

const {add, half, square} = Parent()

add() // 4
add() // 5
add() // 6
half() // 3
square() // 9
```

We define 3 child functions inside the parent function, The `closure` here will be created for our 3 inner functions.
Every time we call one of the function, they will modify the same value.

- All 3 child function share the same parent scope and useses the same variable, we close over the same value in parent scope.

### Returning the value from the function thate we capture will

Returning the value from the function thate we capture will not give us the modified value, since as soon we define out function it will capture the initilized variable in the top and remember that value.
If we want to get back the modified value that we captured inside our function, we can simply create a getter function that just return taht value.
And know we have that modified value back.

So using the same example from above:

```js
function Parent() {
  let x = 3

  const square = () => {
    x = x ** 2
    console.log(x)
  }
  const add = () => {
    x += 1
    console.log(x)
  }
  const half = () => {
    x /= 2
    console.log(x)
  }

  return {
    square,
    add,
    half,
    x,
    getX() {
      return x
    },
  }
}

const {add, half, square, getX, x} = Parent()

add()
add()
add()
half()
square()
getX() // 9
console.log(x) // 3 it will rember just the first intilized value as soon we create a brand new execution context here
```

By returning a getter function with the modfied value we keep the remeberd value inside the function.

#### How I like to vizualize lexical scoping

<!-- ![adasd](closure-mental.png) -->

I like to vizulize the lexical scoping like an builing with a lot of floors, we start at the bottom floor.
We looking for our cat Bella that has run away, we knock on every door to find her.
Now one has seen Bella but they think they saw here higher up in the bulding, so we go up one floor and look for her there, and we repeat this until we find her.

So same concept, if we have deeply nested blocks we start from the most deeply nested function and walk our way up to find the variable we are looking for.

```js
const GLOBAL = "global" // global scope
function grandGrandFather() {
  let age = 92
  function grandFather() {
    function parent(params) {
      function child(params) {
        // Go up to the grandGrandFather scope where it is declared
        console.log(`My grandGrandFather is ${age} years old`)
        console.log(`I also have access to the Global scope  ${GLOBAL} `) // go up to the global scope
      }
      child()
    }
    parent()
  }
  grandFather()
}

grandGrandFather()
```

How is this really related to `closures` Marcell?
We are very close to understand the power of closures, we know how lexical scoping works and that the inner function will have access to the variables/objects of the parent scope.

```js
const counter = () => {
  let i = 0
  const run = () => {
    i++
    console.log(i)
  }
  run()
}
counter()
```

We are invkoing the `run` function inside the `counter function` to log out the result, but let's change it and try to return the inner function instead so we can use it outside the function scope and it's lexical scope, `aka the power of closures`.

```js
const counter = () => {
  let i = 0
  return () => {
    i++
    console.log(i)
  }
}

let runCounter = counter()
runCounter() //1
runCounter() //2
runCounter() //3
```

Now we have more control and can run the inner function the uses lexical scopeing even outside the the function scope, really cool ond poweful.
So simply said the inder function `closes` over the variable `i` from its lexical scope, _`it captures,rememebr the variable`_.
The inner function that get's returned is our `closure`, it remebers what value the `i` is even outside the function scope.

> a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. // MDN web docs

### So what is a closure?

A closure is a function that remembers from the area it was defined, even if we use it later and execute it.
So if you see any variable that is not defined somewhere nearby ore in the function then it is properly a `closure`, it has `captured`,`closed` over that variable.

### Examples of closures

<!-- Working with React hooks you are using `closures`, for example when we build a simple counter with react hooks.
The way how we make our increment counter is that we keep the previos `count` value in closure.
Take a look at this code example, and try to increment and decrement the counter. -->

A simple counter example from the example above using `closures`.
Working with the dom we simply can create a visual representing of a counter and interact with it using `closures`.
We also added a functionality to disable the button when count is equal to 0.
Notice how we capture the count value inside the `counter` function.
We keep track of the count variable and remember what its previous value was.
If we whould defined the count variable inside the `counter` function we would not achive the same result since we would get a brand new `count` value for every function call.

<Counter />

```js
;(() => {
  let count = 0
  const counter = () => {
    const incrementCount = () => {
      ++count
    }
    const decrementCount = () => {
      --count
    }
    return {incrementCount, decrementCount}
  }

  document.getElementById("count").innerHTML = `<span>${count}</span>`

  check()
  document.getElementById("increment").addEventListener("click", () => {
    counter().incrementCount()
    document.getElementById("count").innerHTML = `<span>${count}</span>`
    check()
  })

  document.getElementById("decrement").addEventListener("click", () => {
    counter().decrementCount()
    document.getElementById("count").innerHTML = `<span>${count}</span>`
    check()
  })

  function check() {
    if (count === 0) {
      document.getElementById("decrement").removeAttribute("disabled")
    } else {
      document.getElementById("decrement").setAttribute("disabled", "true")
    }
  }
})()
```

### Higher order functions

**With higher order functions** we are using closures as well, for example when we
try to find a specifik element in alist using `Array.prototype.find`. For example
this code block uses closure to find the correct name in the list.

```js
const names = ["bob", "frank", "tina", "logan"]
const nameToFind = "frank"
const upperNames = names.find((name) => name === nameToFind))
```

We using closures here becasue `nameToFind` is defiend outside of the function, its a `closure`

### Callbacks

**In callbacks** it it common to use closures as well, by capturing the variable from the lexical scope, inside the `fn` function.

```js
const toUpper = (s) => s.toUpperCase()
const firstLetter = (s) => s.slice(0, 1)
const lastLetter = (s) => s.slice(s.length - 1)

const name = "Marcell"

const fn = (anotherFunction) => {
  return anotherFunction(name)
}

console.log(fn(toUpper)) // MARCELL
console.log(fn(firstLetter)) // M
console.log(fn(lastLetter)) // l
```

### Functional progaming

**Curried function**, in functional programing closure is a very important concept since without closure we could not achive curried functions.

```js
const name = "Marcell"
const helloInDifferentLanguages = (lang) => (name) => `${lang} ${name}`

const helloInEng = helloInDifferentLanguages("Hi there")
const helloInSpanish = helloInDifferentLanguages("Hola")
const helloInFrench = helloInDifferentLanguages("Bonjour")
const helloInPortuguese = helloInDifferentLanguages("Olá")

const helloMarcellInEnglish = helloInEng(name)
const helloMarcellInSpanish = helloInSpanish(name)
const helloMarcellInFrench = helloInFrench(name)
const helloMarcellInPortuguese = helloInPortuguese(name)
```

The `helloInDifferentLanguages` is our curried function and it returns another function that return later on the final result.
So basicclu can preload the `helloInDifferentLanguages` with the first argument ny passing on how we say hello in a different language.
And the final step we just add the given name to print out hello in a different language.

Why this concept is so useful is becasue we made our function dynamic, we can have different language and also pass in what name we want to print, all of this thanks to `closures`.

### React hooks

**React hooks** using closures to remember the current state.
For example `useState` under hood is something we can simply implement using closures.
This example was inspired by: [`Shaw Wang`](https://egghead.io/q/resources-by-shawn-wang).

```js
const MyReact = (() => {
  let value
  return {
    render(Component) {
      const comp = Component()
      comp.render()
      return comp
    },

    useState(initialValue) {
      value = value || initialValue
      const setState = (newValue) => {
        value = newValue
      }
      return [value, setState]
    },
  }
})()

function Counter() {
  const [count, setCount] = MyReact.useState(0)
  return {
    click: () => setCount(count + 1),
    render: () => console.log("render:", {count}),
  }
}
let App
App = MyReact.render(Counter) // render: { count: 0 }
App.click()
App = MyReact.render(Counter) // render: { count: 1 }
App.click()
App = MyReact.render(Counter) // render: { count: 2 }
App.click()
App = MyReact.render(Counter) // render: { count: 3 }
```

Notice how we need to reassign the `App` variable for each click, to see the counter to increment. This representing a render in the browser to update the state.
We basiclly using the [`Module pattern`](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript) here to achive a incapulated mini verserion of `React`.
The value variable in the top holds our state in the module scope. We can then caputre the value inside the `useState` metod and updated it.
**Note** this is just a very basic and simple example and React is more complex and prisice under the hood, this is just to demostrate how `React` using closures to implement the usage of `React hooks`.

### conclusion

- By having lexixal scope we can access variables from the outer scope.
- It still the scope that decides how we will access the variable.
- `Closure` is a function the close over a value, capturing the value, it remebers the variableform where it was defined.
- We have a closure when a functions reads and writes a variable that is decalred outside of the function.

  Something to know about closures is that we also need to be careful with them,
  there is a reason why in low level languages like `C` that you don't have
  closures. `Rust` have closures but to use them you need to write a specifik
  syntax to accees variables outside of the function. Closures could be stored
  for a longer time in the memory even after the function call is done. That is
  why it is important to not keep any global variables, and define yout closure
  inside a function. Take the adventage of lexical scoping in `JavScript`.
