---
title: Closures
spoiler: What is closures, and how do they actually work?
date: "2020-03-16"
updated: "2020-03-16"
tags: ["js", "fp"]
keywords: ["wtf", "vip"]
slug: js-closures
---

What are closures actually and why is this a so common term in programming.
If you have been applied for a JavaScript interview you probably got the question from the interviewer that you should explain what a closure is and how it works.
A closure is a function that can access stuff not inside of it.
Every function we create in JavaScript has a closure.
As soon we enable/call our function the closures enable them to access the values from their scopes. So for example

> Closure is something that access the value the that is not defined inside of it.

Like [`Kyle Simpsons`](https://github.com/getify/You-Dont-Know-JS) defines clsures:

> Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.

```js
let name = "Filip"
const whatUp = () => {
  console.log(`hello ${name}`)
}
whatUp() // Filip

name = "Marcell"
whatUp() // Marcell
```

In this example, we will receive first hello Bob and then when we assign the name variable and call the function again we will get hello Marcell. Another good example of how closures work is to implement a simple counter.
Here we expect that the `i` variable should be incremented by one for every function call\. And it does!

```js
let i = 0
const increment = () => {
  ++i
  console.log(i)
}
increment() //1
increment() //2
increment() //3
increment() //4
```

The increment function works as a closure and it is like it has its memory and can remember what the previous I variable was.
So every time we would call the increment function we would receive an updated value of i-variable\.

**Something good to know is that:**
_A closure is created when you define a function not when we execute it. Then, every time we call that function, it will give us access to the defined `closures` from their function scopes\._

> It is the ability of a function to capture anything outside of the function and use that value every time our function gets called, that is what makes closures special.

So what would happened if we define the variable I inside the function?

```js
const increment = () => {
  let i = 0
  ++i
  console.log(i)
}
increment() //1
increment() //1
increment() //1
increment() //1
```

We would not get the same result as the previous example, that the I variable has been updated.
Every time we call the function we create a brand new function within the function scope.

But we don’t want to create global variables in our programs right?
What is so great with function in javascript is that all functions are first-class functions that mean that functions can be passed around as any value, we can define multiple functions inside another function.
The function can be passed as an argument to other functions, can be returned by another function, and can be assigned as a value to a variable.

Take the built-in higher-order functions like `Array.prototype.map`, `Array.prototype.filter`, and `Array.prototype.reduce`, for example, if you used them which is common when you write JavaScript programs, they can access the outer scoper thanks to closures.

But let’s go a little further and try to understand closures better by the understanding how the function life cycle works in `JavaScript.`

## Execution context

_Short about the life cycle of a JavaScript function\._

When we run our function, we create a brand new execution context, a brand new scope, when we are done that scope goes away.
If we call the same function a second time we create a whole different scope for that specifik exacution context, then the second scope goes away.

```js
function saySomething() {
  let name = "Marcell"
  console.log(`Hello there ${name}`)
}

saySomething()
saySomething()
```

The scopes are totaly different and have nothing common at all except that they use the same function.
The variable `name` inside the function will be recreated for every `execution context`.

Every function scope has its own lifetime, thats get created and as soon they are done the functions goes away.
The only scope that never goes away is the `global` scope, that is alive through the whole program.

## Scope and lexical scope

To create scope in JavaScript is when we define a function or a code block for example an if statement.
How we access a variable inside a block is managed by the scope.

So back to our counter-example:
When we define the variable inside the function we can’t access it outside the function scope,
We have simply created a private variable defined inside the function block.
We only have access to the variable inside the function scope.

Since the variables we created are just bounded to the scope where they got created, we can define a new variable with the same name and value inside another function because they are not defined within the same function scope.

We can do nested scopes and here is when the true power kicks in by using closures and understanding how the scope works.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

- You see here how the inner function `(child)` have access to the parent scope.
- We can nest scopes, and the inner function has access to the variables that are defined in the parent scope.
- Parent function does not have access to the child scope\.

  So another example.
  What whould happend in this case? Do we expect the same result, do we get any
  kind of error message since we defining 2 variables within the same name?
  Let's see what result we get\.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    let parentVariable = "From the child"
    console.log(parentVariable)
  }
  child()
}

parent() // From the child
```

We print the value of the variable that gets defined inside the child function, since it was created from its function scope it will use that variable even if we have the same variable defined in the parent scope.
Since they are defined in different scopes we will not get any error, in this case, we just shadowing the parent Variable defined in the parent function scope.

But how can the child functions have access to the variable defined in the parent scope?
As well as how does JavaScript know what variable is corresponds to what scope?
This is when we come to understanding the lexical scope in JavaScript.
JavaScript does also have a concept called a lexical scope, that inside an inner scope we still have access to the outer scope, so in the example the parent scope.

Take the previous example in this case.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

1. Firstm we declare the `parent` function, and the compiler says: _hey I can see that you declared a variable inside the parent function named parent Variable_
2. _Hey but I can also see that you using a variable without any declaration, I know `lexical scoping` so I will just use the variable that is defined in the scope above `(the parent scoper)`_

### Don't mix closures and scopes

We should not mix these two concepts because they are not the same.
Closures span multiple scopes and will not go away even after the function is done executing.
A difference between scopes and closures is that closure will still live after the function execution while scopes have their lifetime.

What will this code print?

```js
let x = 10

function a() {
  console.log(x)
}

function b() {
  let x = 222
  a()
}

b() // ????
```

It will print `10`, since the closure of the `a function` has only access to the global scope and to its own scope, the scope of `function b` where we execute the `a function` does not affect the closure at all.

- Functions has their own scope
- So if the function is not defined inside of the `b function` it will never know what the `x` value is, inside the `b function`. In this case.

### Closures and shared scopes

Closures can even share scopes, So if we have a main function and inside of it 3 other functions, they can modify the variable because they will capture the same value.
So for example:

```js
function Parent() {
  let x = 3

  const square = () => {
    x = x ** 2
    console.log(x)
  }
  const add = () => {
    x += 1
    console.log(x)
  }
  const half = () => {
    x /= 2
    console.log(x)
  }
  return {
    square,
    add,
    half,
  }
}

const {add, half, square} = Parent()

add() // 4
add() // 5
add() // 6
half() // 3
square() // 9
```

We define 3 child functions inside the parent function, The `closure` here will be created for our 3 inner functions.
Every time we call one of the functions, they will modify the same value.

- All 3 child functions share the same parent scope and uses the same variable, we close over the same value in the parent scope.

### Using the captured variable

Returning the value from the function that we capture will not give us the modified value, since as soon we define our function it will capture the initialized variable, that gets defined in the top and remember that value.
If we want to get back the modified value that we captured inside our function, we can simply create a getter function that just returns that value.
And know we have that modified value back.

So using the same example from above:

```js
function Parent() {
  let x = 3

  const square = () => {
    x = x ** 2
    console.log(x)
  }
  const add = () => {
    x += 1
    console.log(x)
  }
  const half = () => {
    x /= 2
    console.log(x)
  }

  return {
    square,
    add,
    half,
    x,
    getX() {
      return x
    },
  }
}

const {add, half, square, getX, x} = Parent()

add()
add()
add()
half()
square()
getX() // 9
console.log(x) // 3 it will hold on to the initialized value, from the function call
```

By returning a getter function with the modfied value we keep the remeberd value inside the function.

#### How I like to vizualize lexical scoping

<!-- ![adasd](/static/images/closure.png) -->

<Image src="/static/images/clo.svg" height={500} width={800} />

I like to visualize the lexical scoping like a building with a lot of floors, we start at the bottom floor.
We looking for our cat Bella that has run away, we knock on every door to find her.
No one has seen Bella but they think they saw her higher up in the building, so we go up one floor and look for her there, and we repeat this until we find her.

So same concept, if we have deeply nested blocks we start from the most deeply nested function and walk our way up to find the variable we are looking for.

```js
const GLOBAL = "global" // global scope
function grandGrandFather() {
  let age = 92
  function grandFather() {
    function parent(params) {
      function child(params) {
        // Go up to the grandGrandFather scope where it is declared
        console.log(`My grandGrandFather is ${age} years old`)
        console.log(`I also have access to the Global scope  ${GLOBAL} `) // go up to the global scope
      }
      child()
    }
    parent()
  }
  grandFather()
}

grandGrandFather()
```

How is this related to `closures` Marcell?
We know how lexical scoping works and that the inner function will have access to the variables/objects of the parent scope.

```js
const counter = () => {
  let i = 0
  const run = () => {
    i++
    console.log(i)
  }
  run()
}
counter()
```

We are invoking the `run` function inside the `counter function` to log out the result, but let's change it and try to return the inner function instead so we can use it outside the function scope and its lexical scope, `aka the power of closures`.

```js
const counter = () => {
  let i = 0
  return () => {
    i++
    console.log(i)
  }
}

let runCounter = counter()
runCounter() //1
runCounter() //2
runCounter() //3
```

Now we have more control and can run the inner function the uses lexical scoping even outside the function scope, really cool and powerful.
So simply said the inner function `closes` over the variable `i` from its lexical scope, _`it captures, remember the variable`_.
The inner function that gets returned is our `closure`, it remembers what value the `i` is even outside the function scope.

> a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. // MDN web docs

### So asking again, what is a closure?

A closure is a function that remembers from the area it was defined, even if we use it later and execute it.
So if you see any variable that is not defined somewhere nearby ore in the function then it is properly a `closure`, it has `captured`,`closed` over that variable.
It is not just a regular function, it is a function combined with its outer state or lexical environment.

### Some examples/use cases of using closures

A simple counter-example from the example above using closures.
Working with the `DOM` we simply can create a visual representing of a counter and interact with it using closures.
We also added a functionality to disable the button when the count is equal to 0.
Notice how we capture the count value inside the counter function.
We keep track of the count variable and remember what its previous value was.
If we would define the count variable inside the counter function we would not achieve the same result since we would get a brand new `count` value for every function call.

<Counter />

```js
;(() => {
  let count = 0
  const counter = () => {
    const incrementCount = () => {
      ++count
    }
    const decrementCount = () => {
      --count
    }
    return {incrementCount, decrementCount}
  }

  document.getElementById("count").innerHTML = `<span>${count}</span>`

  check()
  document.getElementById("increment-button").addEventListener("click", () => {
    counter().incrementCount()
    document.getElementById("count").innerHTML = `<span>${count}</span>`
    check()
  })

  document.getElementById("decrement-button").addEventListener("click", () => {
    counter().decrementCount()
    document.getElementById("count").innerHTML = `<span>${count}</span>`
    check()
  })

  function check() {
    if (count === 0) {
      document.getElementById("decrement-button").removeAttribute("disabled")
    } else {
      document
        .getElementById("decrement-button")
        .setAttribute("disabled", "true")
    }
  }
})()
```

### Higher order functions

**With higher-order functions** we are using closures as well, for example when we
try to find a specific element in alist using `Array.prototype.find`. For example,
this code block uses a closure to find the correct name in the list.

```js
const names = ["bob", "frank", "tina", "logan"]
const nameToFind = "frank"
const upperNames = names.find((name) => name === nameToFind))
```

We using closures here becasue `nameToFind` is defiend outside of the function.

### Callbacks

**In callbacks** it is common to use closures as well, by capturing the variable from the lexical scope, inside the `fn` function.

```js
const toUpper = (s) => s.toUpperCase()
const firstLetter = (s) => s.slice(0, 1)
const lastLetter = (s) => s.slice(s.length - 1)

const name = "Marcell"

const fn = (anotherFunction) => {
  return anotherFunction(name)
}

console.log(fn(toUpper)) // MARCELL
console.log(fn(firstLetter)) // M
console.log(fn(lastLetter)) // l
```

### Functional progaming

**Curried function**, in functional programming closure, is a very important concept since without closure we could not achieve curried functions.

```js
const name = "Marcell"
const helloInDifferentLanguages = (lang) => (name) => `${lang} ${name}`

const helloInEng = helloInDifferentLanguages("Hi there")
const helloInSpanish = helloInDifferentLanguages("Hola")
const helloInFrench = helloInDifferentLanguages("Bonjour")
const helloInPortuguese = helloInDifferentLanguages("Olá")

const helloMarcellInEnglish = helloInEng(name) // Hi there Marcell
const helloMarcellInSpanish = helloInSpanish(name) // Hola Marcell
const helloMarcellInFrench = helloInFrench(name) // Bonjour Marcell
const helloMarcellInPortuguese = helloInPortuguese(name) // Olá Marcell
```

The `helloInDifferentLanguages` is our curried function and it returns another function that returns later on the final result.
So basically can preload the `helloInDifferentLanguages` with the first argument by passing on how we say hello in a different language.
And the final step we just add the given name to print out hello in a different language.

Why this concept is so useful is because we made our function dynamic, we can have a different language and also pass in what name we want to print, all of this thanks to `closures`.

### React hooks

**React hooks** using closures to remember the current state.
For example, `useState` under the hood is something we can simply implement using closures.
This example was inspired by: [`Shaw Wang`](https://egghead.io/q/resources-by-shawn-wang).

```js
const MyReact = (() => {
  let value
  return {
    render(Component) {
      const comp = Component()
      comp.render()
      return comp
    },

    useState(initialValue) {
      value = value || initialValue
      const setState = (newValue) => {
        value = newValue
      }
      return [value, setState]
    },
  }
})()

function Counter() {
  const [count, setCount] = MyReact.useState(0)
  return {
    click: () => setCount(count + 1),
    render: () => console.log("render:", {count}),
  }
}
let App
App = MyReact.render(Counter) // render: { count: 0 }
App.click()
App = MyReact.render(Counter) // render: { count: 1 }
App.click()
App = MyReact.render(Counter) // render: { count: 2 }
App.click()
App = MyReact.render(Counter) // render: { count: 3 }
```

Notice how we need to reassign the `App` variable for each click, to see the counter to increment. This representing a render in the browser to update the state.
We use the [`Module pattern`](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript) here to achieve an encapsulated mini version of `React`.
The value variable at the top holds our state in the module scope. We can then capture the value inside the `useState` method and updated it.
**Note** this is just a very basic and simple example and React is more complex and precise than our simple example, this is just to demonstrate how `React` using closures to implement the usage of `React hooks`.
And to understand closures.

### Closures and Memory

Just short about how closures get stored in memory. Capmapred how to function execution gets stored in the short-term memory, the `call stack`.
Javascript closures get stored on the Heap memory, so we can access them later in our program. This is why we will have access to them later in our program.
The closure will be freed up later by the garbage collector.

### conclusion

- By having lexical scope we can access variables from the outer scope.
- It is still the scope that decides how we will access the variable.
- `Closure` is a function the closes over a value, capturing the value, it remembers the variable form where it was defined.
- We have a closure when a function reads and writes a variable that is declared outside of the function.
- `Closures` get stored on the Heap memory and not on the call stack

Something to know about closures is that we also need to be careful with them,
there is a reason why in low-level languages like `C` that you don't have closures.
`Rust` has closures but to use them you need to write a specific syntax to access variables outside of the function.
Closures could be stored for a longer time in the memory even after the function call is done.
That is why it is important to not keep any global variables, and define our closure inside a function.
