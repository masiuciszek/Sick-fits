---
title: Closures
spoiler: What is closures, and how do they actually work?
date: "2020-03-16"
updated: "2020-03-16"
tags: ["js", "fp"]
keywords: ["wtf", "vip"]
slug: js-closures
---

What are closures actually and why is this a so common term in programming.
If you have been applied for a JavaScript interview you probably got the question from the interviewer that you should explain what a closure is and how it works.

A closure is a function that can access stuff not inside of it.
So for example

> Closure is something that access the value the that is not defined inside of it.

```js
let name = "Filip"
const whatUp = () => {
  console.log(`hello ${name}`)
}
whatUp() // Filip

name = "Marcell"
whatUp() // Marcell
```

In this example, we will receive first hello Bob and then when we assign the name variable and call the function again we will get hello Marcell.

Another good example of how closures work is if we would define our variable inside the function or outside, and what kind of differences would we get.

```js
let i = 0
const increment = () => {
  ++i
  console.log(i)
}
increment() //1
increment() //2
increment() //3
increment() //4
```

The increment function works as a closure and it is like it has its own memory and can remember what the previous I variable was.
So every time we would call the increment function we would receive an updated value of i-variable.

> It is the ability of a function to capture anything outside of the function and use that value every time our function gets called, that is what makes closures special.

So what would happened if we define the variable I inside the function?

```js
const increment = () => {
  let i = 0
  ++i
  console.log(i)
}
increment() //1
increment() //1
increment() //1
increment() //1
```

We would not get the same result as the previous example, that the I variable has been updated.
Every time we call the function we create a brand new function within the funcion scope.

But we don’t want to create global variables in our programs right?
What is so great with function in javascript is that all functions are first-class functions that mean that functions can be passed around as any value, we can define multiple functions inside another function.
The function can be passed as an argument to other functions, can be returned by another function, and can be assigned as a value to a variable.

Take the built-in higher-order functions like `Array.prototype.map`, `Array.prototype.filter`, and `Array.prototype.reduce`, for example, if you used them which is common when you write JavaScript programs, they can access the outer scoper thanks to closures.

But let’s go a little further and try to understand closures better by the understanding scope and lexical scope in JavaScript.

To create scope in JavaScript is when we define a function or a code block for example an if statement.

How we access a variable inside a block is managed by the scope.

So back to our counter-example:
When we define the variable inside the function we can’t access it outside the function scope,
We have simply created a private variable defined inside the function block.
We only have access to the variable inside the function scope.

Since the variables we create are just bounded to the scope where they got created, we can define a new variable with the same name and value inside another function because they are not defined within the same function scope.

We can do nested scopes and here is when the true power kicks in by using closures and understanding how the scope works.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

- You see here how the inner function `(child)` have access to the parent scope.
- We can nest scopes, and the inner function has access to the variables that are defined in the parent scope.
- Parent function does not have access to the child scope.

What whould happend in this case?
Do we expect the same result, do we get the same kind of error since we defining 2 variables within the same name?
Let's see what result we get.'

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    let parentVariable = "From the child"
    console.log(parentVariable)
  }
  child()
}

parent() // From the child
```

We print the value of the variable that gets defined inside the child function, since it was created from its function scope it will use that variable even if we have the same variable defined in the parent scope.
Since they are defined in different scopes we will not get any error, in this case, we just shadowing the `parentVariable` defined in the parent function scope.

But how can the child functions have access to the variable defined in the parent scope? As well as how does JavaScript knows what variable is corsponds to what scope?
This is when we come to understanding the `lexical` scope in JavaScript.
JavaScript does also have a concept called `lexical scope`, that inside a inner scope we still have acceess to the outer scope, so in the example the parent scope.

We can brake it down in to a metafor how the compiler compile ot JavaScript code.

Take the first example in this case.

```js
function parent() {
  let parentVariable = "Hello there"
  function child() {
    console.log(parentVariable)
  }
  child()
}

parent() // Hello there
```

1. First we declare the `parent` function, and the compiler says: _hey I can see that you declared a varaible inside the parent function named `parentVariable`_
2. _Hey but I can also see that you using a variable without any declaration, I know `lexical scoping` so I will just use the variable that is defined in scope above `(the parent scoper)`_

#### How I like to vizualize lexical scoping

I like to vizulize the lexical scoping like an builing with a lot of floors, we start at the bottom floor.
We looking for our cat Bella that has run away, we knock on every door to find her.
Now one has seen Bella but they think they saw here higher up in the bulding, so we go up one floor and look for her there, and we repeat this until we find her.

So same concept, if we have deeply nested blocks we start from the most deeply nested function and walk our way up to find the variable.

```js
const GLOBAL = "global" // global scope
function grandGrandFather() {
  let age = 92
  function grandFather() {
    function parent(params) {
      function child(params) {
        // Go up to the grandGrandFather scope where it is declared
        console.log(`My grandGrandFather is ${age} years old`)
        console.log(`I also have access to the Global scope  ${GLOBAL} `) // go up to the global scope
      }
      child()
    }
    parent()
  }
  grandFather()
}

grandGrandFather()
```

But is does how `closures` works or what are you explaing here Marcell?
We are very close to understand the power of closures, we know how lexical scoping works and that the inner function will have access to the variables/objects of the parent scope.

```js
const counter = () => {
  let i = 0
  const run = () => {
    i++
    console.log(i)
  }
  run()
}
counter()
```

We are invkoing the `run` function inside the `counter function` to log out the result, but let's change it and try to return the inner function instead so we can use it outside the function scope and it's lexical scope, `aka the power of closures`.

```js
const counter = () => {
  let i = 0
  return () => {
    i++
    console.log(i)
  }
}

let runCounter = counter()
runCounter() //1
runCounter() //2
runCounter() //3
```

Now we have more control and can run the inner function the uses lexical scopeing even outside the the function scope, really cool ond poweful.
So simply said the inder function `closes` over the variable `i` from its lexical scope, _`it captures,rememebr the variable`_.
The inner function that get's returned is our `closure`, it remebers what value the `i` is even outside the function scope.

> a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time. // MDN web docs

### So what is a closure?

A closure is a function that remembers from the area it was defined, even if we use it later and execute it.
So if you see any variable that is not defined somewhere nearby ore in the function then it is properly a `closure`, it has `captured`,`closed` over that variable.

### Examples of closures

Working with React hooks you are using `closures`, for example when we build a simple counter with react hooks.
The way how we make our increment counter is that we keep the previos `count` value in closure.
Take a look at this code example, and try to increment and decrement the counter.

<Counter />

```tsx
import {useState} from "react"

const Counter = () => {
  const [state, setState] = useState(0)
  return (
    <aside>
      <h1>count is {state}</h1>
      <div className="buttons">
        <button onClick={() => setState((prevState) => prevState + 1)}>
          increment
        </button>
        <button onClick={() => setState((prevState) => prevState - 1)}>
          decrement
        </button>
      </div>
    </aside>
  )
}

export default Counter
```

---

**With higher order functions** we are using closures as well, for example when we try to transform one list into a new list using `Array.prototype.find`.
For example this code block uses closure to find the correct name in the list.

```js
const names = ["bob", "frank", "tina", "logan"]
const nameToFind = "frank"
const upperNames = names.find((name) => name === nameToFind))
```

We using closures here becasue `nameToFind` is defiend outside of the function, its a `closure`

---

**In callbacks** it it common to use closures as well, by capturing the variable from the lexical scope, inside the `fn` function.

```js
const toUpper = (s) => s.toUpperCase()
const firstLetter = (s) => s.slice(0, 1)
const lastLetter = (s) => s.slice(s.length - 1)

const name = "Marcell"

const fn = (anotherFunction) => {
  return anotherFunction(name)
}

console.log(fn(toUpper)) // MARCELL
console.log(fn(firstLetter)) // M
console.log(fn(lastLetter)) // l
```

---

**Curried function**, in functional programing closure is a very important concept since without closure we could not achive curried functions.

```js
const name = "Marcell"
const helloInDifferentLanguages = (lang) => (name) => `${lang} ${name}`

const helloInEng = helloInDifferentLanguages("Hi there")
const helloInSpanish = helloInDifferentLanguages("Hola")
const helloInFrench = helloInDifferentLanguages("Bonjour")
const helloInPortuguese = helloInDifferentLanguages("Olá")

const helloMarcellInEnglish = helloInEng(name)
const helloMarcellInSpanish = helloInSpanish(name)
const helloMarcellInFrench = helloInFrench(name)
const helloMarcellInPortuguese = helloInPortuguese(name)
```

The `helloInDifferentLanguages` is our curried function and it returns another function that return later on the final result.
So basicclu can preload the `helloInDifferentLanguages` with the first argument ny passing on how we say hello in a different language.
And the final step we just add the given name to print out hello in a different language.

Why this concept is so useful is becasue we made our function dynamic, we can have different language and also pass in what name we want to print, all of this thanks to `closures`.

### conclusion

- By having lexixal scope we can access variables from the outer scope.
- It still the scope that decides how we will access the variable.
- `Closure` is a function the close over a value, capturing the value, it remebers the variableform where it was defined.
- We have a closure when a functions reads and writes a variable that is decalred outside of the function.
  <br />
  <br />
  Something to know about closures is that we also need to be careful with them,
  there is a reason why in low level languages like `C` that you don't have
  closures. `Rust` have closures but to use them you need to write a specifik
  syntax to accees variables outside of the function. Closures could be stored
  for a longer time in the memory even after the function call is done. That is
  why it is important to not keep any global variables, and define yout closure
  inside a function. Take the adventage of lexical scoping in `JavScript`.
